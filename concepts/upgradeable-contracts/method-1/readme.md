# Contract migration

Версионирование смарт-контрактов и миграция состояний из одной версии в другую.

Основная идея заключается в создание нового контракта и перенос в него состояния из старого контракта. Изначально новый развернутый контракт будет иметь пустое хранилище.

Процесс перехода на новую версию может выглядеть следующим образом:
1. Создание нового экземпляра контракта.
2. Перенос состояния или миграция данных. Это может быть реализовано двумя способами:
 - **On-chain.** Миграция при помощи смарт-контрактов.
 - **Off-chain.** Сбор данных со старого контракта происходит за пределами блокчейна. На последнем этапе собранные данные записываются по адресу нового контракта.
3. Обновить адрес нового контракта для всех контрактов, сервисов и клиентских приложений. То есть заменить старый адрес, на новый.
4. Убедить пользователей перейти на использование нового контракта. Если это контракт токена, вам также необходимо связаться с биржами, чтобы отказаться от старого контракта и использовать новый контракт.

_Важно !_ Перенос данных относительно несложная и простая операция, но она может занять значительное время и потребовать значительных затрат на газ. Также стоит помнить, что не все пользователи захотят перейти на новую версию, а значит необходимо продумывать меры поддержки для таких пользователей и старых версий контрактов.

## On-chain
Миграция при помощи смарт-контрактов. Такая миграция может быть реализована двумя способами.
- **За счет пользователя.** Когда мы предлагаем пользователю заплатить за газ. Мы пишем некий функционал миграции, который при вызове определяет пользователя и переносит функционал на новый контракт.
- **За счет мигратора.** Мы можем это делать за счет протокола и переносить состояния в ручную или при помощи еще одного контракта. В этом случае затраты на газ покрывает компания(владельцы контрактов, протокола).

## Off-chain
Считываем все данные из блокчейн. Если был взлом или сбой, то читать необходимо до блока со сбоем. При этом работу действующего смарт-контракта лучше приостановить(если это возможно). Все публичные примитивы легко считываются. Для приватных переменных чуть сложнее, но можно полагаться на события(Events) или использовать метод ```getStorageAt()``` для чтения таких переменных из хранилища. Массивы также легко восстанавливаются, поскольку известно количество элементов. С mapping все намного сложнее, так как ключи не сохраняются, поэтому можно полагаться только на события(Event). После сбора всех данных необходимо записать их на новый контракт.

Чтобы восстановить данные из событий необходимо понимать, как события хранятся, как индексируются и как фильтруются за пределами блокчейн. Про это хорошо описано [тут](https://medium.com/mycrypto/understanding-event-logs-on-the-ethereum-blockchain-f4ae7ba50378).

Одним из вариантов сбора данных является использования сервиса [Google BigQuery API](https://cloud.google.com/blog/products/data-analytics/ethereum-bigquery-public-dataset-smart-contract-analytics)

Подробнее с примерами смотреть [тут](./big-query.md)

# Links

1. [How contract migration works](https://blog.trailofbits.com/2018/10/29/how-contract-migration-works/)
2. [EthersJS. Events. Logs and filtering](https://docs.ethers.org/v5/concepts/events/#events--filters)
3. [Solidity documentation. Events](https://docs.soliditylang.org/en/v0.8.18/contracts.html#events)
4. [Understanding event logs on the Ethereum blockchain](https://medium.com/mycrypto/understanding-event-logs-on-the-ethereum-blockchain-f4ae7ba50378)